use crate::ast::{Ast, Block, CodeAttributes, CodeMeta};
use crate::document::DocumentMetadata;

use anyhow::Context;
use base64;
use base64::Engine;

use linked_hash_map::LinkedHashMap;
use pulldown_cmark::{Options, Parser};
use serde::de::Error;
use serde::{Deserialize, Deserializer, Serialize, Serializer};
use serde_json::Value;
use serde_with::{formats::PreferOne, serde_as, EnumMap, OneOrMany};
use std::default::Default;

/// Top-level notebook structure (the type is a mostly complete implementation of the official
/// notebook specification (http://ipython.org/ipython-doc/3/notebook/nbformat.html).
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct Notebook {
    /// Information about the kernel and cell language.
    pub metadata: NotebookMeta,
    #[serde(default = "nbformat")]
    /// Notebook format (4 is the modern version)
    pub nbformat: i64,
    /// Minor version
    #[serde(default = "nbformat_minor")]
    pub nbformat_minor: i64,
    /// The actual content (cells) of the notebook
    pub cells: Vec<Cell>,
}

const fn nbformat() -> i64 {
    4
}

const fn nbformat_minor() -> i64 {
    5
}

/// Cell structure
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(tag = "cell_type")]
pub enum Cell {
    /// Markdown cells are parsed as regular markdown
    #[serde(rename = "markdown")]
    Markdown {
        #[serde(flatten)]
        common: CellCommon,
    },
    /// Code cells can be executed and can contain saved outputs
    #[serde(rename = "code")]
    Code {
        #[serde(flatten)]
        common: CellCommon,

        /// Notebooks save how many time code cells have been run
        execution_count: Option<i64>,
        /// Execution results are saved as well
        outputs: Vec<CellOutput>,
    },
    /// Raw cells don't perform a function in the notebook but are used for specifying cdoc
    /// metadata.
    #[serde(rename = "raw")]
    Raw {
        #[serde(flatten)]
        common: CellCommon,
    },
}

/// Stuff common to all cell types
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct CellCommon {
    pub metadata: CellMeta,
    /// Cell sources are stored as lists of source lines in the notebook file.
    /// It is parsed into a single string for convenience (and is deserialized to the list representation).
    #[serde(
        deserialize_with = "concatenate_deserialize",
        serialize_with = "concatenate_serialize"
    )]
    pub source: String,
}

/// Stream type used for stream output.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "lowercase")]
pub enum StreamType {
    StdOut,
    StdErr,
}

impl ToString for StreamType {
    fn to_string(&self) -> String {
        match self {
            StreamType::StdOut => "stdout".to_string(),
            StreamType::StdErr => "stderr".to_string(),
        }
    }
}

/// Notebooks can save execution outputs in a variety of formats. Representing these makes it easy
/// to replicate their types in the rendered output.
#[serde_as]
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(tag = "output_type")]
pub enum CellOutput {
    /// Used for outputs generated by stdio/stderr. For rendering purposes this is the same as regular text.
    #[serde(rename = "stream")]
    Stream {
        name: StreamType,
        #[serde(deserialize_with = "concatenate_deserialize")]
        text: String,
    },
    /// Complex output values (correspond to mime-types)
    #[serde(rename = "display_data", alias = "execute_result")]
    Data {
        execution_count: Option<i64>,
        /// The content of the output (may be multiple)
        #[serde_as(as = "EnumMap")]
        data: Vec<OutputValue>,
        metadata: LinkedHashMap<String, Value>,
    },
    #[serde(rename = "error")]
    Error {
        ename: String,
        evalue: String,
        traceback: Vec<String>,
    },
}

/// Complex cell outputs
#[serde_as]
#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum OutputValue {
    /// Regular text
    #[serde(rename = "text/plain")]
    Plain(
        /// May be saved as either a string or a list of line strings.
        #[serde_as(
            deserialize_as = "OneOrMany<_, PreferOne>",
            serialize_as = "OneOrMany<_, PreferOne>"
        )]
        Vec<String>,
    ),
    /// Png image
    #[serde(rename = "image/png")]
    Image(
        #[serde_as(
            deserialize_as = "OneOrMany<_, PreferOne>",
            serialize_as = "OneOrMany<_, PreferOne>"
        )]
        Vec<String>,
    ),
    /// Svg image
    #[serde(rename = "image/svg+xml")]
    Svg(
        #[serde_as(
            deserialize_as = "OneOrMany<_, PreferOne>",
            serialize_as = "OneOrMany<_, PreferOne>"
        )]
        Vec<String>,
    ),
    /// Json
    #[serde(rename = "application/json")]
    Json(LinkedHashMap<String, Value>),
    /// Html
    #[serde(rename = "text/html")]
    Html(
        #[serde_as(
            deserialize_as = "OneOrMany<_, PreferOne>",
            serialize_as = "OneOrMany<_, PreferOne>"
        )]
        Vec<String>,
    ),
    /// Javascript
    #[serde(rename = "application/javascript")]
    Javascript(
        #[serde_as(
            deserialize_as = "OneOrMany<_, PreferOne>",
            serialize_as = "OneOrMany<_, PreferOne>"
        )]
        Vec<String>,
    ),
}

type Dict = LinkedHashMap<String, Value>;

/// Notebook metadata. Currently not precisely specified.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct NotebookMeta {
    /// Kernel specification
    pub kernelspec: Option<LinkedHashMap<String, Value>>,
    #[serde(flatten)]
    pub optional: Dict,
}

/// Controls cell display and function in notebook applications and is also used for rendering outputs.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct CellMeta {
    /// Cell is collapsed (can be shown).
    pub collapsed: Option<bool>,
    pub autoscroll: Option<Value>,
    pub deletable: Option<bool>,
    /// JupyterLab specific options
    pub jupyter: Option<JupyterLabMeta>,
    pub format: Option<String>,
    pub name: Option<String>,
    /// Tags are useful for creating custom flags for cells.
    pub tags: Option<Vec<String>>,
    #[serde(flatten)]
    pub additional: Dict,
}

/// Extra metadata for the JupyterLab application
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct JupyterLabMeta {
    /// Hide cell outputs
    pub outputs_hidden: Option<bool>,
    /// Hide cell source but show outputs
    pub source_hidden: Option<bool>,
}

impl Notebook {
    /// Get cdoc frontmatter from notebook (this must be a raw cell at the top of the document).
    pub fn get_front_matter(&self) -> Result<DocumentMetadata, serde_yaml::Error> {
        match &self.cells[0] {
            Cell::Raw { common } => Ok(serde_yaml::from_str(&common.source)?),
            _ => Ok(DocumentMetadata::default()),
        }
    }
}

fn concatenate_deserialize<'de, D>(input: D) -> Result<String, D::Error>
where
    D: Deserializer<'de>,
{
    let base: Vec<String> = Deserialize::deserialize(input)?;
    let source: String = base.into_iter().collect();
    //let source = unescape(&source);
    Ok(source)
}

fn concatenate_serialize<S>(value: &str, serializer: S) -> Result<S::Ok, S::Error>
where
    S: Serializer,
{
    let lines: Vec<&str> = value.split('\n').collect();
    let last = lines[lines.len() - 1];
    let mut new_lines: Vec<String> = lines[..lines.len() - 1]
        .iter()
        .map(|s| format!("{}\n", s))
        .collect();
    new_lines.push(last.to_string());
    serializer.collect_seq(new_lines)
}

#[allow(unused)]
fn deserialize_png<'de, D>(input: D) -> Result<Vec<u8>, D::Error>
where
    D: Deserializer<'de>,
{
    let base: String = Deserialize::deserialize(input)?;
    let engine = base64::engine::general_purpose::STANDARD;
    let bytes = engine
        .decode(base)
        .map_err(|e| D::Error::custom(e.to_string()))?;
    // let source = load_from_memory(&bytes).map_err(|e| D::Error::custom(e.to_string()))?;
    Ok(bytes)
}

#[allow(unused)]
fn serialize_png<S>(value: &Vec<u8>, serializer: S) -> Result<S::Ok, S::Error>
where
    S: Serializer,
{
    let engine = base64::engine::general_purpose::STANDARD;
    serializer.collect_str(&engine.encode(value))
}

impl TryFrom<Cell> for Vec<Block> {
    type Error = anyhow::Error;

    fn try_from(value: Cell) -> Result<Self, Self::Error> {
        Ok(match value {
            Cell::Markdown { common } => {
                let ast: Ast = Ast::make_from_iter(Parser::new_ext(&common.source, Options::all()))
                    .context("when parsing markdown notebook cell")?;
                ast.0
            }
            Cell::Code {
                common, outputs, ..
            } => {
                vec![Block::CodeBlock {
                    source: common.source,
                    reference: None,
                    attr: CodeAttributes {
                        editable: true,
                        fold: common.metadata.collapsed.unwrap_or(false),
                    },
                    tags: common.metadata.tags,
                    meta: CodeMeta::default(),
                    outputs,
                    display_cell: true,
                }]
            }
            Cell::Raw { .. } => {
                vec![]
            }
        })
    }
}

impl TryFrom<Notebook> for Ast {
    type Error = anyhow::Error;

    fn try_from(value: Notebook) -> Result<Self, Self::Error> {
        Ok(Ast(value
            .cells
            .into_iter()
            .map(|c| -> anyhow::Result<Vec<Block>> { c.try_into() })
            .collect::<anyhow::Result<Vec<Vec<Block>>>>()?
            .into_iter()
            .flatten()
            .collect()))
    }
}

#[cfg(test)]
mod tests {
    use crate::notebook::Notebook;

    use std::fs::File;
    use std::io::BufReader;
    use std::path::PathBuf;

    #[test]
    fn deserialize() {
        let mut d = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        d.push("resources/test/test.ipynb");
        let bf = BufReader::new(File::open(d).expect("Could not open file"));
        let _nb: Notebook = serde_json::from_reader(bf).expect("Deserialization failed");

        println!("Done");
    }
}
